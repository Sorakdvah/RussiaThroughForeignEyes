<!-- Черновая сборка -- не работает автозагрузка глав, только вручную -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Я фотографирую Россию (с примечаниями)</title>
    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            transition: background-color 0.3s ease, color 0.3s ease;
            background-color: white;
            color: black;
        }
        body.dark-mode {
            background-color: black;
            color: white;
        }
        body.dark-mode .bg-white {
            background-color: #1a1a1a !important;
        }
        body.dark-mode .text-gray-600 {
            color: #a0aec0 !important;
        }
        body.dark-mode .shadow-lg {
            box-shadow: 0 10px 15px -3px rgba(255, 255, 255, 0.1), 0 4px 6px -2px rgba(255, 255, 255, 0.05) !important;
        }
        body.dark-mode .comment {
            background-color: #2a2a2a;
        }
        body.footnote-active {
            position: relative;
        }
        body.footnote-active::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(5px);
            z-index: 1000;
            pointer-events: none;
        }
        body.no-scroll {
            overflow: hidden;
            position: fixed;
            width: 100%;
        }
        .footnote.active,
        .comment.visible {
            position: relative;
            z-index: 1002;
        }
        .enlarged-image-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 9999;
        }
        .enlarged-image {
            max-width: 90%;
            max-height: 90%;
            object-fit: contain;
        }

        /* Новые стили для оглавления в темном режиме */
        body.dark-mode .table-of-contents {
            background-color: #1a1a1a;
            color: #e0e0e0;
        }
        body.dark-mode .table-of-contents li.active {
            background-color: #2c2c2c;
            color: #ffffff;
        }
        .footnote-container {
            display: inline;
            cursor: pointer;
        }
        .footnote-wrapper {
            border-bottom: 1px dotted #999;
            position: relative;
            z-index: 1000; /* Поместить поверх размытия */
        }
        .footnote-wrapper.active {
            position: relative;
            z-index: 1001;
        }
        .footnote {
            cursor: pointer;
            border-bottom: 1px dotted #999;
        }
        .footnote-text {
            display: inline;
        }
        .footnote sup {
            border-bottom: none !important;
            text-decoration: none !important;
            margin-left: 1px;
        }
        .footnote-star {
            border-bottom: none !important;
            text-decoration: none !important;
            margin-left: 1px;
            cursor: pointer;
        }
        .comment {
            background-color: #f0f0f0;
            padding: 5px;
            border-radius: 3px;
            margin-left: 0;
            font-style: italic;
            position: relative;
            z-index: 1001;
        }

        .px-4 {
            color: text-zinc-600;
        }
        body.dark-mode .px-4 {
            color: white;
        }
    </style>
</head>
<script type="text/babel">
    // Константы для кэширования и загрузки
    const CACHE_PREFIX = 'book_chapter_';
    const CACHE_VERSION = 'v1';
    const CHAPTERS_PER_FETCH = 2;
    const STORAGE_KEYS = {
      THEME: 'reader_theme',
      ACTIVE_CHAPTER: 'reader_active_chapter',
      FONT_SIZE: 'reader_font_size',
    };

    // Имитация API для тестирования
    const mockAPI = {
        async fetchChapter(index) {
            try {
                const response = await fetch('/book_final.txt');
                const text = await response.text();
                // Разделяем текст на главы по заголовкам
                const chapters = text.split(/(?=# )/).filter(Boolean);

                if (index < chapters.length) {
                    return {
                        content: chapters[index],
                        title: chapters[index].split('\n')[0].replace('# ', '')
                    };
                }
                return null;
            } catch (error) {
                console.error('Error fetching chapter:', error);
                throw error;
            }
        },

        async fetchBookMetadata() {
            try {
                const response = await fetch('/book_final.txt');
                const text = await response.text();
                // Подсчитываем количество глав
                const chapters = text.split(/(?=# )/).filter(Boolean);
                return {
                    totalChapters: chapters.length,
                    title: "Я фотографирую Россию",
                    author: "Unknown"
                };
            } catch (error) {
                console.error('Error fetching metadata:', error);
                throw error;
            }
        }
    };

    // Модифицированный хук useChapterLoader
    const useChapterLoader = () => {
        const [chapters, setChapters] = React.useState([]);
        const [loadedChapterIndices, setLoadedChapterIndices] = React.useState(new Set());
        const [isLoading, setIsLoading] = React.useState(true);
        const [error, setError] = React.useState(null);
        const [allChapterTitles, setAllChapterTitles] = React.useState([]);
        const initializeRef = React.useRef(false);

        // Выносим загрузку главы в отдельную функцию для переиспользования
        const fetchAndLoadChapter = React.useCallback(async (chapterIndex) => {
            try {
                const chapterData = await mockAPI.fetchChapter(chapterIndex);
                if (!chapterData) return null;

                // Сохраняем в кэш
                localStorage.setItem(
                    `${CACHE_PREFIX}${CACHE_VERSION}_${chapterIndex}`,
                    JSON.stringify(chapterData)
                );

                const parsedChapter = parseContent(chapterData.content);
                return parsedChapter;
            } catch (err) {
                console.error(`Error loading chapter ${chapterIndex}:`, err);
                return null;
            }
        }, []);

        const loadChapter = React.useCallback(async (chapterIndex) => {
            if (loadedChapterIndices.has(chapterIndex) || chapterIndex < 0 || chapterIndex >= allChapterTitles.length) {
                return;
            }

            setIsLoading(true);
            try {
                // Проверяем кэш
                const cachedData = localStorage.getItem(
                    `${CACHE_PREFIX}${CACHE_VERSION}_${chapterIndex}`
                );

                let chapterContent;
                if (cachedData) {
                    chapterContent = parseContent(JSON.parse(cachedData).content);
                } else {
                    chapterContent = await fetchAndLoadChapter(chapterIndex);
                }

                if (chapterContent) {
                    setChapters(prev => {
                        const newChapters = [...prev];
                        newChapters[chapterIndex] = chapterContent;
                        return newChapters;
                    });
                    setLoadedChapterIndices(prev => new Set(prev).add(chapterIndex));
                }
            } catch (err) {
                setError(err.message);
            } finally {
                setIsLoading(false);
            }
        }, [loadedChapterIndices, allChapterTitles.length, fetchAndLoadChapter]);

        // Инициализация с принудительной загрузкой первой главы
        React.useEffect(() => {
            const initializeChapters = async () => {
                if (initializeRef.current) return;
                initializeRef.current = true;

                try {
                    const response = await fetch('/book_final.txt');
                    const text = await response.text();
                    const chapters = text.split(/(?=# )/).filter(Boolean);
                    const titles = chapters.map(chapter => {
                        const firstLine = chapter.split('\n')[0];
                        return firstLine.replace('# ', '');
                    });

                    setAllChapterTitles(titles);
                    // Инициализируем массив глав
                    setChapters(new Array(titles.length).fill(null));

                    // Немедленно загружаем первую главу
                    const firstChapter = await fetchAndLoadChapter(0);
                    if (firstChapter) {
                        setChapters(prev => {
                            const newChapters = [...prev];
                            newChapters[0] = firstChapter;
                            return newChapters;
                        });
                        setLoadedChapterIndices(new Set([0]));
                    }
                } catch (err) {
                    setError(err.message);
                } finally {
                    setIsLoading(false);
                }
            };

            initializeChapters();
        }, [fetchAndLoadChapter]);

        return {
            chapters,
            isLoading,
            error,
            loadChapter,
            loadedChapterIndices,
            allChapterTitles
        };
    };


    const ControlPanel = ({
        toggleToc,
        increaseFontSize,
        decreaseFontSize,
        isVisible,
        toggleTheme,
        isDarkTheme,
        tocIsOpen
    }) => {

        // Функция для перехода на стартовую страницу
        const goToHomePage = () => {
            window.location.href = '/index.html';  // Укажите здесь нужный URL, если отличается от "/"
        };

        return (
            <div
                className={`fixed top-0 left-0 right-0 z-[1005] transition-all duration-300 ${
                    (isVisible || tocIsOpen) ? 'translate-y-0' : '-translate-y-full'
                }`}
            >
                <div className="bg-white shadow-md p-2 flex justify-between items-center">

                    {/* Кнопка для переключения оглавления */}
                    <button
                        onClick={toggleToc}
                        className={`w-8 h-8 flex items-center justify-center transition-colors duration-200
                            ${tocIsOpen ? 'text-zinc-200' : 'text-gray-600'}
                        `}
                    >
                        ☰
                    </button>

                    <div className="flex items-center">
                        {/* Новая кнопка "Домой" */}
                        <button
                            onClick={goToHomePage}
                            className="w-8 h-8 flex items-center justify-center text-gray-600 hover:text-gray-900 transition-colors duration-200 mr-2 size-auto"
                            title="Домой"
                        >
                            ⎗
                        </button>

                        {/* Кнопки для изменения размера шрифта */}
                        <button
                            onClick={decreaseFontSize}
                            className="w-8 h-8 rounded-full flex items-center justify-center text-gray-600 hover:text-gray-900 transition-colors duration-200 mr-2"
                        >
                            A-
                        </button>
                        <button
                            onClick={increaseFontSize}
                            className="w-8 h-8 rounded-full flex items-center justify-center text-gray-600 hover:text-gray-900 transition-colors duration-200 mr-2"
                        >
                            A+
                        </button>

                        {/* Кнопка для переключения темы */}
                        <button
                            onClick={toggleTheme}
                            className="w-8 h-8 rounded-full flex items-center justify-center text-gray-600 hover:text-gray-900 transition-colors duration-200"
                        >
                            {isDarkTheme ? '⚪' : '⚫'}
                        </button>
                    </div>
                </div>
            </div>
        );
    };

    // Модифицированный компонент Footnote со звездочкой
    const Footnote = ({ children, comment }) => {
        const [isVisible, setIsVisible] = React.useState(false);
        const footnoteRef = React.useRef(null);
        const commentRef = React.useRef(null);

        React.useEffect(() => {
            const handleClickOutside = (event) => {
                if (footnoteRef.current && !footnoteRef.current.contains(event.target) &&
                    commentRef.current && !commentRef.current.contains(event.target)) {
                    setIsVisible(false);
                    document.body.classList.remove('footnote-active');
                }
            };

            document.addEventListener('mousedown', handleClickOutside);
            return () => {
                document.removeEventListener('mousedown', handleClickOutside);
            };
        }, []);

        const toggleComment = (e) => {
            e.stopPropagation();
            setIsVisible(!isVisible);
            document.body.classList.toggle('footnote-active', !isVisible);
        };

        return (
            <span className="footnote-container">
                <span
                    ref={footnoteRef}
                    className={`footnote-wrapper ${isVisible ? 'active' : ''}`}
                    onClick={toggleComment}
                >
                    <span
                        className="footnote-text"
                        style={{ borderBottom: 'none !important' }}
                        dangerouslySetInnerHTML={{ __html: parseInlineFormatting(children) }}
                    />
                    <sup className="footnote-star">*</sup>
                </span>
                {isVisible && (
                    <span
                        ref={commentRef}
                        className="comment visible"
                    >
                        {comment}
                    </span>
                )}
            </span>
        );
    };

    const parseContent = (content) => {
        const blocks = [];
        const lines = content.split('\n');
        let inImageBlock = false;
        let currentImages = [];
        let chapters = [];
        let inCenteredTextBlock = false;
        let centeredTextContent = []; // для накопления текста внутри многострочного блока

        lines.forEach(line => {
            if (line.trim().startsWith('# ')) {
                const chapterTitle = line.trim().slice(2);
                chapters.push(chapterTitle);
                blocks.push({ type: 'chapter', content: chapterTitle });
            } else if (line.trim() === '[IMG]') {
                inImageBlock = true;
                currentImages = [];
            } else if (line.trim() === '[/IMG]') {
                if (currentImages.length > 0) {
                    blocks.push({ type: 'image', content: currentImages });
                }
                inImageBlock = false;
            } else if (inImageBlock) {
                if (line.trim()) {
                    currentImages.push(line.trim());
                }
            }
            // Проверяем начало многострочного блока
            else if (line.trim() === '@' && !inCenteredTextBlock) {
                inCenteredTextBlock = true;
                centeredTextContent = []; // очищаем накопитель для многострочного текста
            }
            // Проверяем конец многострочного блока
            else if (line.trim() === '@' && inCenteredTextBlock) {
                // Если текст накоплен, добавляем его как блок centeredText
                if (centeredTextContent.length > 0) {
                    blocks.push({
                        type: 'centeredText',
                        content: parseInlineFormatting(centeredTextContent.join('\n').trim())
                    });
                }
                inCenteredTextBlock = false; // завершаем многострочный блок
            }
            // Накопление текста в многострочном блоке
            else if (inCenteredTextBlock) {
                centeredTextContent.push(line);
            }
            // Обработка одиночного блока @текст@
            else if (line.startsWith('@') && line.endsWith('@')) {
                blocks.push({
                    type: 'centeredText',
                    content: parseInlineFormatting(line.slice(1, -1).trim())
                });
            }
            // Обычный текст, если он не в многострочном блоке
            else {
                const match = line.trim().match(/^<p>(.*)<\/p>$/);
                if (match) {
                    blocks.push({
                        type: 'text',
                        content: parseInlineFormatting(match[1].trim())
                    });
                }
            }
        });

        return { blocks, chapters };
    };

    const TextBlock = ({ content, fontSize }) => {
        return (
            <span
                style={{
                    fontSize: `${fontSize}px`,
                    textIndent: '30px',
                    display: 'block'
                }}
                dangerouslySetInnerHTML={{
                    __html: parseInlineFormatting(content)  // Применяем здесь
                }}
            />
        );
    };

    const CenteredTextBlock = ({ content }) => {
        return (
            <div
                style={{
                    display: 'flex',
                    justifyContent: 'center',
                    padding: '10px 10%',
                    flexDirection: 'column'
                }}
                dangerouslySetInnerHTML={{
                    __html: parseInlineFormatting(content)  // Применяем здесь
                }}
            />
        );
    };

    const ImageBlock = ({ content, setIsImageEnlarged }) => {
        const [currentIndex, setCurrentIndex] = React.useState(0);
        const [isEnlarged, setIsEnlarged] = React.useState(false);
        const [maxCaptionHeight, setMaxCaptionHeight] = React.useState(0);
        const imageRef = React.useRef(null);
        const captionRefs = React.useRef([]);

        // Создаем массив изображений с их URL и подписями
        const images = [];
        for (let i = 0; i < content.length; i += 2) {
            images.push({
                url: content[i],
                caption: content[i + 1] || ''
            });
        }

        // Используем useEffect для расчета максимальной высоты подписей
        React.useEffect(() => {
            // Сбрасываем высоту перед новым расчетом
            setMaxCaptionHeight(0);

            // Ждем следующего тика для уверенности, что DOM обновился
            requestAnimationFrame(() => {
                const heights = captionRefs.current
                    .filter(ref => ref) // Убираем null значения
                    .map(ref => ref.offsetHeight);

                if (heights.length > 0) {
                    const maxHeight = Math.max(...heights);
                    setMaxCaptionHeight(maxHeight);
                }
            });
        }, [content]); // Пересчитываем при изменении контента

        const nextImage = (e) => {
            e.stopPropagation();
            setCurrentIndex((prevIndex) => (prevIndex + 1) % images.length);
        };

        const prevImage = (e) => {
            e.stopPropagation();
            setCurrentIndex((prevIndex) => (prevIndex - 1 + images.length) % images.length);
        };

        const toggleEnlarged = (e) => {
            e.stopPropagation();
            setIsEnlarged(!isEnlarged);
            setIsImageEnlarged(!isEnlarged);
        };

        // Определяем, нужно ли показывать кнопки навигации
        const showNavigationButtons = images.length > 1;

        return (
            <div className="my-8 p-4 bg-white text-gray-600">
                <div
                    className="relative flex justify-center items-center"
                    style={{
                        maxWidth: '100%',
                        height: '350px',
                        overflow: 'hidden'
                    }}
                >
                    <img
                        ref={imageRef}
                        src={images[currentIndex].url}
                        alt={images[currentIndex].caption}
                        className="cursor-pointer object-contain max-w-full max-h-full"
                        onClick={toggleEnlarged}
                    />

                    {/* Показываем кнопки навигации только если есть больше одного изображения */}
                    {showNavigationButtons && (
                        <>
                            <button
                                onClick={prevImage}
                                className="absolute left-2 top-1/2 transform -translate-y-1/2 p-8 bg-zinc-200 bg-opacity-50 hover:bg-opacity-80 text-stone-200 rounded-full"
                            >
                                ❮
                            </button>
                            <button
                                onClick={nextImage}
                                className="absolute right-2 top-1/2 transform -translate-y-1/2 p-8 bg-zinc-200 bg-opacity-50 hover:bg-opacity-80 text-white rounded-full"
                            >
                                ❯
                            </button>
                        </>
                    )}
                </div>

                {/* Контейнер для подписи с фиксированной высотой */}
                <div
                    className="mt-4"
                    style={{
                        height: maxCaptionHeight > 0 ? `${maxCaptionHeight}px` : 'auto',
                        overflow: 'hidden'
                    }}
                >
                    <span
                        ref={el => {
                            captionRefs.current[currentIndex] = el;
                        }}
                        className="block text-center font-style: italic max-w-[90%] mx-auto"
                    >
                        {renderTextWithFootnotes(images[currentIndex].caption)}
                    </span>
                </div>

                {isEnlarged && (
                    <div
                        className="enlarged-image-container"
                        onClick={toggleEnlarged}
                    >
                        <img
                            src={images[currentIndex].url}
                            alt={images[currentIndex].caption}
                            className="enlarged-image"
                        />
                    </div>
                )}
            </div>
        );
    };


    // Модифицированный компонент TableOfContents
    const TableOfContents = ({
        chapters,
        allChapterTitles,
        activeChapter,
        onChapterSelect,
        isOpen,
        width = '32rem',
        isMobile
    }) => {
        const listRef = React.useRef(null);
        const activeItemRef = React.useRef(null);

        React.useEffect(() => {
            if (isOpen && activeItemRef.current && listRef.current) {
                const listContainer = listRef.current;
                const activeItem = activeItemRef.current;
                const itemTop = activeItem.offsetTop;
                const containerHeight = listContainer.clientHeight;
                const itemHeight = activeItem.clientHeight;
                listContainer.scrollTop = itemTop - (containerHeight / 2) + (itemHeight / 2);
            }
        }, [activeChapter, isOpen]);

        if (!isOpen) return null;

        return (
            <>
                {isMobile && (
                    <div className="fixed inset-0 bg-black bg-opacity-50 z-[1000]" />
                )}

                <div
                    ref={listRef}
                    className={`table-of-contents bg-white overflow-auto shadow-lg z-50 transition-transform duration-300
                        ${isMobile
                            ? 'fixed inset-0 z-[1004]'
                            : 'fixed top-0 right-0 h-full w-72 transform'
                        }`}
                >
                    <div className="p-6">
                        <ul className="space-y-2 mt-12">
                            {allChapterTitles.map((title, index) => (
                                <li
                                    key={index}
                                    ref={index === activeChapter ? activeItemRef : null}
                                    className={`cursor-pointer p-2 rounded transition-colors
                                        ${activeChapter === index
                                            ? 'bg-zinc-300 dark:bg-zinc-100 dark:text-black font-bold'
                                            : 'hover:bg-gray-100'
                                        }`}
                                    onClick={() => onChapterSelect(index)}
                                >
                                    {title}
                                </li>
                            ))}
                        </ul>
                    </div>
                </div>
            </>
        );
    };

    // Новый компонент навигации между главами
    const ChapterNavigation = ({
        activeChapter,
        totalChapters,
        onChapterSelect,
        isVisible,
        tocIsOpen,
        isMobile
    }) => {
        const [forceShow, setForceShow] = React.useState(false);

        React.useEffect(() => {
            const handleScroll = () => {
                // Определяем, находимся ли мы близко к концу страницы
                const scrollPosition = window.scrollY + window.innerHeight;
                const pageHeight = document.documentElement.scrollHeight;
                const isNearBottom = pageHeight - scrollPosition < 100; // 100px от конца

                setForceShow(isNearBottom);
            };

            window.addEventListener('scroll', handleScroll, { passive: true });
            return () => window.removeEventListener('scroll', handleScroll);
        }, []);

        const showPrevButton = activeChapter > 0;
        const showNextButton = activeChapter < totalChapters - 1;

        // Показываем навигацию если isVisible === true ИЛИ forceShow === true
        const shouldShow = isVisible || forceShow;

        return (
            <div className={`fixed bottom-0 left-0 right-0 z-[1001] transition-all duration-300 ease-in-out
                ${shouldShow ? 'translate-y-0' : 'translate-y-full'}
                ${(isMobile && tocIsOpen) ? 'opacity-0' : 'opacity-100'}
                ${tocIsOpen && !isMobile ? 'pr-72' : ''}`}
            >
                <div className="max-w-3xl min-w-[350px] mx-auto p-2 bg-white shadow-lg dark:white flex justify-between items-center">
                    {showPrevButton ? (
                        <button
                            onClick={() => onChapterSelect(activeChapter - 1)}
                            className="px-4 py-2 bg-white hover:font-semibold"
                        >
                            ← Глава {activeChapter}
                        </button>
                    ) : <div />}

                    {showNextButton ? (
                        <button
                            onClick={() => onChapterSelect(activeChapter + 1)}
                            className="px-4 py-2 bg-white hover:font-semibold"
                        >
                            Глава {activeChapter + 2} →
                        </button>
                    ) : <div />}
                </div>
            </div>
        );
    };

    // Parsing function for inline formatting (italic, bold)
    const parseInlineFormatting = (text) => {
        // Parse italic text
        text = text.replace(/\/\/(.*?)\/\//g, '<i>$1</i>');
        // Parse bold text
        text = text.replace(/\|\|(.*?)\|\|/g, '<strong>$1</strong>');
        return text;
    };

    // Модифицированный основной компонент
    const App = () => {
        // Инициализация состояний
        const [fontSize, setFontSize] = React.useState(() => {
            const saved = localStorage.getItem(STORAGE_KEYS.FONT_SIZE);
            return saved ? parseInt(saved, 10) : 16;
        });

        const [showToc, setShowToc] = React.useState(false);
        const [activeChapter, setActiveChapter] = React.useState(() => {
            const saved = localStorage.getItem(STORAGE_KEYS.ACTIVE_CHAPTER);
            return saved ? parseInt(saved, 10) : 0;
        });

        const [isDarkTheme, setIsDarkTheme] = React.useState(() => {
            const saved = localStorage.getItem(STORAGE_KEYS.THEME);
            const initialTheme = saved ? saved === 'dark' : false;
            if (initialTheme) {
                document.body.classList.add('dark-mode');
            }
            return initialTheme;
        });

        const [lastScrollTop, setLastScrollTop] = React.useState(0);
        const [showControlPanel, setShowControlPanel] = React.useState(true);
        const [isImageEnlarged, setIsImageEnlarged] = React.useState(false);

        // Добавляем состояние для определения мобильного устройства
        const [isMobile, setIsMobile] = React.useState(false);

        const [isScrollLocked, setIsScrollLocked] = React.useState(false);
        const scrollTimeout = React.useRef(null);
        const lastScrollUpdateTime = React.useRef(Date.now());

        // Используем useRef для хранения текущей позиции прокрутки
        const currentScrollPosition = React.useRef(0);

        const [isManualScrolling, setIsManualScrolling] = React.useState(false);
        const [isChapterTransition, setIsChapterTransition] = React.useState(false);
        const lastAutoScrollTimestamp = React.useRef(0);

        React.useEffect(() => {
            let scrollTimeout;

            const handleScroll = () => {
                const currentTime = Date.now();

                // Игнорируем события прокрутки во время программной навигации
                if (isChapterTransition || currentTime - lastAutoScrollTimestamp.current < 1000) {
                    return;
                }

                const scrollY = window.scrollY + window.innerHeight / 3;
                let newActiveIndex = activeChapter;

                // Находим текущую видимую главу
                chapterRefs.current.forEach((ref, index) => {
                    if (ref && ref.offsetTop <= scrollY) {
                        newActiveIndex = index;
                    }
                });

                // Обновляем активную главу только при ручной прокрутке
                if (newActiveIndex !== activeChapter && !isChapterTransition) {
                    setActiveChapter(newActiveIndex);
                }
            };

            window.addEventListener('scroll', handleScroll, { passive: true });
            return () => {
                window.removeEventListener('scroll', handleScroll);
                clearTimeout(scrollTimeout);
            };
        }, [activeChapter, isChapterTransition]);

        // Функция для обновления состояния isMobile при изменении размера окна
        React.useEffect(() => {
            const checkMobileView = () => {
                setIsMobile(window.innerWidth < 768); // Определяем как мобильное устройство, если ширина экрана меньше 768px
            };

            checkMobileView(); // Проверяем при загрузке
            window.addEventListener('resize', checkMobileView); // Обновляем при изменении размера окна
            return () => window.removeEventListener('resize', checkMobileView);
        }, []);

        // Остальные состояния и обработчики
        const [loadedChapterIndices, setLoadedChapterIndices] = React.useState([]);
        const { chapters, isLoading, error, loadChapter, allChapterTitles } = useChapterLoader();
        const chapterRefs = React.useRef([]);

        React.useEffect(() => {
            localStorage.setItem(STORAGE_KEYS.THEME, isDarkTheme ? 'dark' : 'light');
        }, [isDarkTheme]);

        React.useEffect(() => {
            localStorage.setItem(STORAGE_KEYS.ACTIVE_CHAPTER, activeChapter.toString());
        }, [activeChapter]);

        React.useEffect(() => {
            localStorage.setItem(STORAGE_KEYS.FONT_SIZE, fontSize.toString());
        }, [fontSize]);

        React.useEffect(() => {
            const handleScroll = () => {
                const st = window.pageYOffset || document.documentElement.scrollTop;
                setShowControlPanel(st < lastScrollTop);
                setLastScrollTop(st <= 0 ? 0 : st);
            };

            window.addEventListener('scroll', handleScroll);
            return () => window.removeEventListener('scroll', handleScroll);
        }, [lastScrollTop]);

          React.useEffect(() => {
            const initialLoadChapters = async () => {
              const savedChapter = parseInt(localStorage.getItem(STORAGE_KEYS.ACTIVE_CHAPTER), 10) || 0;

              // Сначала загружаем текущую главу
              await loadChapter(savedChapter);
              setLoadedChapterIndices(prev => [...prev, savedChapter]);

            };

            if (allChapterTitles.length > 0) {
              initialLoadChapters();
            }
          }, [loadChapter, allChapterTitles.length]);

        React.useEffect(() => {
            const handleScroll = async () => {
                const scrollPosition = window.scrollY + window.innerHeight;
                const totalHeight = document.body.scrollHeight;

                if (scrollPosition >= totalHeight * 0.8) {
                    const nextChapterIndex = Math.max(...loadedChapterIndices) + 1;
                    if (nextChapterIndex < allChapterTitles.length) {
                        await loadChapter(nextChapterIndex);
                        setLoadedChapterIndices(prev => [...prev, nextChapterIndex]);
                    }
                }

                const topScrollPosition = window.scrollY;
                if (topScrollPosition <= window.innerHeight * 0.3) {
                    const prevChapterIndex = Math.min(...loadedChapterIndices) - 1;
                    if (prevChapterIndex >= 0) {
                        await loadChapter(prevChapterIndex);
                        setLoadedChapterIndices(prev => [...prev, prevChapterIndex]);
                    }
                }

                const scrollY = window.scrollY + window.innerHeight / 3;
                let newActiveIndex = 0;
                chapterRefs.current.forEach((ref, index) => {
                    if (ref && ref.offsetTop <= scrollY) {
                        newActiveIndex = index;
                    }
                });
                if (newActiveIndex !== activeChapter) {
                    setActiveChapter(newActiveIndex);
                }
            };

            window.addEventListener('scroll', handleScroll);
            return () => window.removeEventListener('scroll', handleScroll);
        }, [loadChapter, loadedChapterIndices, allChapterTitles.length, activeChapter]);

        const handleChapterSelect = async (index) => {
            if (index < 0 || index >= allChapterTitles.length) {
                return;
            }

            setIsChapterTransition(true);
            setActiveChapter(index);

            // Сбрасываем прокрутку в начало страницы
            window.scrollTo(0, 0);

            // Загружаем выбранную главу, если она еще не загружена
            if (!loadedChapterIndices.includes(index)) {
                await loadChapter(index);
                setLoadedChapterIndices(prev => [...prev, index]);
            }

            if (isMobile) {
                setShowToc(false);
            }

            // Загружаем соседние главы после переключения
            const loadNeighboringChapters = async () => {
                const chaptersToLoad = [index - 1, index + 1]
                    .filter(idx =>
                        idx >= 0 &&
                        idx < allChapterTitles.length &&
                        !loadedChapterIndices.includes(idx)
                    );
                await Promise.all(chaptersToLoad.map(idx => loadChapter(idx)));
            };

            // Асинхронно загружаем соседние главы
            loadNeighboringChapters();

            // Убираем флаг перехода
            setIsChapterTransition(false);
        };

            // Обновленный эффект для отслеживания загруженных глав
        React.useEffect(() => {
            const updateChapterRefs = () => {
                chapters.forEach((chapter, index) => {
                    if (chapter) {
                        const element = document.querySelector(`[data-chapter-index="${index}"]`);
                        if (element) {
                            chapterRefs.current[index] = element;
                        }
                    }
                });
            };

            updateChapterRefs();

            // Обновляем refs после каждой загрузки новой главы
            const observer = new MutationObserver(updateChapterRefs);
            observer.observe(document.getElementById('root'), {
                childList: true,
                subtree: true
            });

            return () => observer.disconnect();
        }, [chapters]);

        const toggleToc = () => setShowToc(!showToc);

        const increaseFontSize = () => {
            setFontSize(prev => Math.min(prev + 2, 24));
        };

        const decreaseFontSize = () => {
            setFontSize(prev => Math.max(prev - 2, 12));
        };

        const toggleTheme = () => {
            setIsDarkTheme(!isDarkTheme);
            document.body.classList.toggle('dark-mode');
        };

        return (
            <div className="App">
                <div className={`transition-all duration-300 ${showToc && !isMobile ? 'mr-72' : ''}`}>
                    <div className="max-w-3xl mx-auto relative min-w-[350px]">
                        <ControlPanel
                            toggleToc={toggleToc}
                            increaseFontSize={increaseFontSize}
                            decreaseFontSize={decreaseFontSize}
                            isVisible={showControlPanel && !isImageEnlarged}
                            toggleTheme={toggleTheme}
                            isDarkTheme={isDarkTheme}
                            tocIsOpen={showToc}
                        />

                        {isLoading && (
                            <div className="text-center py-4">
                                <span className="inline-block px-4 py-2 text-gray-200 rounded">
                                    Загрузка...
                                </span>
                            </div>
                        )}

                        {error && (
                            <div className="text-center py-4">
                                <span className="inline-block px-4 py-2 bg-red-100 text-red-700 rounded">
                                    {error}
                                </span>
                            </div>
                        )}

                        <div className="p-4">
                            <div className="bg-white shadow-lg rounded-lg p-6">
                                {/* Отображаем только активную главу */}
                                {chapters[activeChapter] && (
                                    <div
                                        key={activeChapter}
                                        ref={el => chapterRefs.current[activeChapter] = el}
                                        data-chapter-index={activeChapter}
                                        className="mb-32" // Добавляем большой отступ после каждой главы
                                    >
                                        {chapters[activeChapter].blocks.map((block, blockIndex) => {
                                            if (block.type === 'text') {
                                                return (
                                                    <p key={blockIndex} style={{ fontSize: `${fontSize}px`, textIndent: 30 }}>
                                                        {renderTextWithFootnotes(block.content)}
                                                    </p>
                                                );
                                            } else if (block.type === 'centeredText') {
                                                return (
                                                    <CenteredTextBlock
                                                        key={blockIndex}
                                                        content={block.content}
                                                    />
                                                );
                                            } else if (block.type === 'chapter') {
                                                return (
                                                    <h1 key={blockIndex} className="text-2xl font-bold my-16">
                                                        {block.content}
                                                    </h1>
                                                );
                                            } else if (block.type === 'image') {
                                                return (
                                                    <ImageBlock
                                                        key={blockIndex}
                                                        content={block.content}
                                                        setIsImageEnlarged={setIsImageEnlarged}
                                                    />
                                                );
                                            }
                                            return null;
                                        })}
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>
                </div>

                {showToc && (
                    <TableOfContents
                        chapters={chapters}
                        allChapterTitles={allChapterTitles}
                        activeChapter={activeChapter}
                        onChapterSelect={handleChapterSelect}
                        isOpen={showToc}
                        isMobile={isMobile}
                    />
                )}
                <ChapterNavigation
                    activeChapter={activeChapter}
                    totalChapters={allChapterTitles.length}
                    onChapterSelect={handleChapterSelect}
                    isVisible={showControlPanel && !isImageEnlarged}
                    allChapterTitles={allChapterTitles}
                    tocIsOpen={showToc}
                    isMobile={isMobile}
                />
            </div>
        );
    };


    // Вспомогательные функции для рендеринга текста с примечаниями
    const renderTextWithFootnotes = (text) => {
      const footnoteRegex = /\[([^\]]+)\*([^\]]+)\*\*\]/g;
      const parts = text.split(footnoteRegex);

      return parts.map((part, i) => {
        if (i % 3 === 1) {
          const word = part;
          const comment = parts[i + 1];
          return (
            <Footnote key={i} comment={comment}>
              {word}
            </Footnote>
          );
        } else if (i % 3 === 0) {
          return (
            <span
              key={i}
              dangerouslySetInnerHTML={{
                __html: parseInlineFormatting(part)
              }}
            />
          );
        }
        return null;
      });
    };

    // Рендерим приложение
    ReactDOM.render(<App />, document.getElementById('root'));
</script>
<body>
<div id="root"></div>
    <div id="overlay"></div>
</body>
</html>
