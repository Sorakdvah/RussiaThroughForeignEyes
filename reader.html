<!-- Счетчик прочтений заработал -->
<!-- Черновая сборка -- не работает автозагрузка глав, только вручную -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Я фотографирую Россию (beta)</title>
        <!-- Open Graph мета-теги -->
    <meta property="og:title" content="Я фотографирую Россию - Джеймс Э. Эбби" />
    <meta property="og:description" content="Путевые заметки американского фотографа о путешествии по России в 1932 году" />
    <meta property="og:type" content="book" />
    <meta property="og:url" content="https://sorakdvah.github.io/RussiaThroughForeignEyes/" />
    <meta property="og:image" content="https://sorakdvah.github.io/RussiaThroughForeignEyes/preview.jpg" />
    <meta property="og:image:width" content="615" />
    <meta property="og:image:height" content="615" />
    <meta property="og:site_name" content="Я фотографирую Россию" />
    <meta property="book:author" content="Джеймс Э. Эбби" />
    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
    <style>
        body {
            transition: background-color 0.3s ease, color 0.3s ease;
            background-color: white;
            color: black;
        }
        body.dark-mode {
            background-color: black;
            color: white;
        }
        body.dark-mode .bg-white {
            background-color: #1a1a1a !important;
        }
        body.dark-mode .text-gray-600 {
            color: #a0aec0 !important;
        }
        body.dark-mode .shadow-lg {
            box-shadow: 0 10px 15px -3px rgba(255, 255, 255, 0.1), 0 4px 6px -2px rgba(255, 255, 255, 0.05) !important;
        }
        body.dark-mode .comment {
            background-color: #2a2a2a;
        }
        body.footnote-active {
            position: relative;
        }
        body.footnote-active::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.1);
            -webkit-backdrop-filter: blur(5px); /* Замыливание для Safari */
            backdrop-filter: blur(5px);
            z-index: 1000;
            pointer-events: none;
        }
        body.no-scroll {
            overflow: hidden;
            position: fixed;
            width: 100%;
        }
        .footnote.active,
        .comment.visible {
            position: relative;
            z-index: 1002;
        }
        .enlarged-image-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 1010;
        }
        .enlarged-image {
            max-width: 90%;
            max-height: 90%;
            object-fit: contain;
        }

        /* Новые стили для оглавления в темном режиме */
        body.dark-mode .table-of-contents {
            background-color: #1a1a1a;
            color: #e0e0e0;
        }
        body.dark-mode .table-of-contents li.active {
            background-color: #2c2c2c;
            color: #ffffff;
        }
        .ChapterNavigation {
            z-index: 1002;
        }
        .footnote-container {
            display: inline;
            cursor: pointer;
        }
        .footnote-wrapper {
            border-bottom: 1px dotted #999;
            position: relative;
            z-index: 1000; /* Поместить поверх размытия */
        }
        .footnote-wrapper.active {
            position: relative;
            z-index: 1001;
        }
        .footnote {
            cursor: pointer;
            border-bottom: 1px dotted #999;
        }
        .footnote-text {
            display: inline;
        }
        .footnote sup {
            border-bottom: none !important;
            text-decoration: none !important;
            margin-left: 1px;
        }
        .footnote-star {
            border-bottom: none !important;
            text-decoration: none !important;
            margin-left: 1px;
            cursor: pointer;
        }
        .comment {
            background-color: #f0f0f0;
            padding: 5px;
            border-radius: 3px;
            margin-left: 0;
            font-style: italic;
            position: relative;
            z-index: 1001;
        }

        .px-4 {
            color: text-zinc-600;
        }
        body.dark-mode .px-4 {
            color: white;
        }
    </style>
</head>
<!-- Добавляем инициализацию Firebase -->
<script>
const firebaseConfig = {
  apiKey: process.env.REACT_APP_FIREBASE_API_KEY,
  authDomain: process.env.REACT_APP_FIREBASE_AUTH_DOMAIN,
  databaseURL: process.env.REACT_APP_FIREBASE_DATABASEURL,
  projectId: process.env.REACT_APP_FIREBASE_PROJECTID,
  storageBucket: process.env.REACT_APP_FIREBASE_STORAGEBUCKET,
  messagingSenderId: process.env.REACT_APP_FIREBASE_MESSAGINGSENDERID,
  appId: process.env.REACT_APP_FIREBASE_APPID,
  measurementId: process.env.REACT_APP_FIREBASE_MEASUREMENTID
};

// Initialize Firebase
const app = firebase.initializeApp(firebaseConfig);
const database = firebase.database();

database.ref('test').set({ message: 'Hello, Firebase!' })
    .then(() => console.log('Test data written successfully!'))
    .catch(error => console.error('Error writing test data:', error));
</script>
<script type="text/babel">
    // Константы для кэширования и загрузки
    const CACHE_PREFIX = 'book_chapter_';
    const CACHE_VERSION = 'v1';
    const CHAPTERS_PER_FETCH = 2;
    const STORAGE_KEYS = {
      THEME: 'reader_theme',
      ACTIVE_CHAPTER: 'reader_active_chapter',
      FONT_SIZE: 'reader_font_size',
    };

    // Код для отслеживания чтения, который будет работать с Babel
    const ReadingTracker = {
        userId: null,
        readChapters: new Set(),
        currentChapter: null,
        scrollProgress: 0,
        hasTrackedCurrentChapter: false,

        init() {
            let userId = localStorage.getItem('reader_user_id');
            if (!userId) {
                userId = ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>
                    (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
                );
                localStorage.setItem('reader_user_id', userId);
            }
            this.userId = userId;

            const savedChapters = JSON.parse(localStorage.getItem('read_chapters') || '[]');
            this.readChapters = new Set(savedChapters);
        },

        setCurrentChapter(chapterIndex) {
            this.currentChapter = chapterIndex;
            this.hasTrackedCurrentChapter = this.readChapters.has(chapterIndex.toString());
            this.scrollProgress = 0;
        },

        updateScrollProgress(progress) {
            this.scrollProgress = progress;
            if (progress >= 0.7 && !this.hasTrackedCurrentChapter && this.currentChapter !== null) {
                this.trackReading();
            }
        },

        trackReading() {
            if (this.hasTrackedCurrentChapter) {
                console.log('Chapter already tracked. Skipping...');
                return;
            }

            console.log('Tracking reading for chapter:', this.currentChapter);

            const userChapterRef = database.ref(`users/${this.userId}/chapters/${this.currentChapter}`);
            const chapterRef = database.ref(`chapters/${this.currentChapter}`);
            const totalReadersRef = database.ref('totalReaders');

            userChapterRef.transaction((currentValue) => {
                if (currentValue === null) {
                    console.log('Marking chapter as read in transaction...');
                    chapterRef.transaction((chapterValue) => (chapterValue || 0) + 1);
                    totalReadersRef.transaction((totalValue) => (totalValue || 0) + 1);
                    return true;
                } else {
                    console.log('Chapter already tracked in transaction.');
                    return currentValue;
                }
            }).then(() => {
                this.readChapters.add(this.currentChapter.toString());
                localStorage.setItem('read_chapters', JSON.stringify([...this.readChapters]));
                this.hasTrackedCurrentChapter = true;
            }).catch(error => console.error('Error tracking reading:', error));
        },

        getReadingStats() {
            return database.ref().once('value')
                .then(snapshot => {
                    const data = snapshot.val() || {};
                    return {
                        totalReaders: data.totalReaders || 0,
                        chapterStats: data.chapters || {}
                    };
                })
                .catch(error => {
                    console.error('Error getting reading stats:', error);
                    return null;
                });
        },

        getChapterReadCount(chapterIndex) {
            return database.ref(`chapters/${chapterIndex}`).once('value')
                .then(snapshot => snapshot.val() || 0)
                .catch(error => {
                    console.error('Error fetching chapter read count:', error);
                    return 0;
                });
        }
    };

    // Создаём один экземпляр трекера для всего приложения
    const readingTracker = Object.create(ReadingTracker);

    // Имитация API для тестирования
    const mockAPI = {
        async fetchChapter(index) {
            try {
                const response = await fetch('book_final.txt');
                const text = await response.text();
                // Разделяем текст на главы по заголовкам
                const chapters = text.split(/(?=# )/).filter(Boolean);

                if (index < chapters.length) {
                    return {
                        content: chapters[index],
                        title: chapters[index].split('\n')[0].replace('# ', '')
                    };
                }
                return null;
            } catch (error) {
                console.error('Error fetching chapter:', error);
                throw error;
            }
        },

        async fetchBookMetadata() {
            try {
                const response = await fetch('book_final.txt');
                const text = await response.text();
                // Подсчитываем количество глав
                const chapters = text.split(/(?=# )/).filter(Boolean);
                return {
                    totalChapters: chapters.length,
                    title: "Я фотографирую Россию",
                    author: "Джеймс Э. Эбби"
                };
            } catch (error) {
                console.error('Error fetching metadata:', error);
                throw error;
            }
        }
    };

    // Модифицированный хук useChapterLoader
    const useChapterLoader = () => {
        const [chapters, setChapters] = React.useState([]);
        const [loadedChapterIndices, setLoadedChapterIndices] = React.useState(new Set());
        const [isLoading, setIsLoading] = React.useState(true);
        const [error, setError] = React.useState(null);
        const [allChapterTitles, setAllChapterTitles] = React.useState([]);
        const initializeRef = React.useRef(false);

        // Выносим загрузку главы в отдельную функцию для переиспользования
        const fetchAndLoadChapter = React.useCallback(async (chapterIndex) => {
            try {
                const chapterData = await mockAPI.fetchChapter(chapterIndex);
                if (!chapterData) return null;

                // Сохраняем в кэш
                localStorage.setItem(
                    `${CACHE_PREFIX}${CACHE_VERSION}_${chapterIndex}`,
                    JSON.stringify(chapterData)
                );

                const parsedChapter = parseContent(chapterData.content);
                return parsedChapter;
            } catch (err) {
                console.error(`Error loading chapter ${chapterIndex}:`, err);
                return null;
            }
        }, []);

        const loadChapter = React.useCallback(async (chapterIndex) => {
            if (loadedChapterIndices.has(chapterIndex) || chapterIndex < 0 || chapterIndex >= allChapterTitles.length) {
                return;
            }

            setIsLoading(true);
            try {
                // Проверяем кэш
                const cachedData = localStorage.getItem(
                    `${CACHE_PREFIX}${CACHE_VERSION}_${chapterIndex}`
                );

                let chapterContent;
                if (cachedData) {
                    chapterContent = parseContent(JSON.parse(cachedData).content);
                } else {
                    chapterContent = await fetchAndLoadChapter(chapterIndex);
                }

                if (chapterContent) {
                    setChapters(prev => {
                        const newChapters = [...prev];
                        newChapters[chapterIndex] = chapterContent;
                        return newChapters;
                    });
                    setLoadedChapterIndices(prev => new Set(prev).add(chapterIndex));
                }
            } catch (err) {
                setError(err.message);
            } finally {
                setIsLoading(false);
            }
        }, [loadedChapterIndices, allChapterTitles.length, fetchAndLoadChapter]);

        // Инициализация с принудительной загрузкой первой главы
        React.useEffect(() => {
            const initializeChapters = async () => {
                if (initializeRef.current) return;
                initializeRef.current = true;

                try {
                    const response = await fetch('book_final.txt');
                    const text = await response.text();
                    const chapters = text.split(/(?=# )/).filter(Boolean);
                    const titles = chapters.map(chapter => {
                        const firstLine = chapter.split('\n')[0];
                        return firstLine.replace('# ', '');
                    });

                    setAllChapterTitles(titles);
                    // Инициализируем массив глав
                    setChapters(new Array(titles.length).fill(null));

                    // Немедленно загружаем первую главу
                    const firstChapter = await fetchAndLoadChapter(0);
                    if (firstChapter) {
                        setChapters(prev => {
                            const newChapters = [...prev];
                            newChapters[0] = firstChapter;
                            return newChapters;
                        });
                        setLoadedChapterIndices(new Set([0]));
                    }
                } catch (err) {
                    setError(err.message);
                } finally {
                    setIsLoading(false);
                }
            };

            initializeChapters();
        }, [fetchAndLoadChapter]);

        return {
            chapters,
            isLoading,
            error,
            loadChapter,
            loadedChapterIndices,
            allChapterTitles
        };
    };

    const ControlPanel = ({
      toggleToc,
      increaseFontSize,
      decreaseFontSize,
      isVisible,
      toggleTheme,
      isDarkTheme,
      tocIsOpen
    }) => {
      const [isAtTop, setIsAtTop] = React.useState(true);

      React.useEffect(() => {
        const handleScroll = () => {
          setIsAtTop(window.scrollY === 0);
        };

        window.addEventListener('scroll', handleScroll);
        // Начальная проверка
        handleScroll();

        return () => window.removeEventListener('scroll', handleScroll);
      }, []);

      const goToHomePage = () => {
        window.location.href = 'https://russiathroughforeigneyes.ru/index.html#library';
      };

      return (
        <div
          className={`fixed top-0 left-0 right-0 transform transition-transform duration-300 ease-in-out bg-white shadow-md ${
            (isVisible || tocIsOpen || isAtTop) ? 'translate-y-0' : '-translate-y-full'
          }`}
          style={{
            position: '-webkit-sticky',
            willChange: 'transform',
            backfaceVisibility: 'hidden',
            WebkitBackfaceVisibility: 'hidden',
            zIndex: 1005
          }}
        >
          <div className="relative flex justify-between items-center p-2">
            <button
              onClick={toggleToc}
              className={`w-8 h-8 flex items-center justify-center transition-colors duration-200 ${
                tocIsOpen ? 'text-zinc-200' : 'text-gray-600'
              } hover:text-gray-900 active:text-gray-900`}
              style={{ touchAction: 'manipulation' }}
            >
              ☰
            </button>
            <div className="flex items-center">
              <button
                onClick={goToHomePage}
                className="w-8 h-8 flex items-center justify-center text-gray-600 hover:text-gray-900 transition-colors duration-200 mr-2"
                style={{ touchAction: 'manipulation' }}
              >
                ⎗
              </button>
              <button
                onClick={decreaseFontSize}
                className="w-8 h-8 flex items-center justify-center text-gray-600 hover:text-gray-900 transition-colors duration-200 mr-2"
                style={{ touchAction: 'manipulation' }}
              >
                A-
              </button>
              <button
                onClick={increaseFontSize}
                className="w-8 h-8 flex items-center justify-center text-gray-600 hover:text-gray-900 transition-colors duration-200 mr-2"
                style={{ touchAction: 'manipulation' }}
              >
                A+
              </button>
              <button
                onClick={toggleTheme}
                className="w-8 h-8 flex items-center justify-center text-gray-600 hover:text-gray-900 transition-colors duration-200"
                style={{ touchAction: 'manipulation' }}
              >
                {isDarkTheme ? '⚪' : '⚫'}
              </button>
            </div>
          </div>
        </div>
      );
    };

    // Модифицированный компонент Footnote со звездочкой
    const Footnote = ({ children, comment }) => {
        const [isVisible, setIsVisible] = React.useState(false);
        const footnoteRef = React.useRef(null);
        const commentRef = React.useRef(null);

        React.useEffect(() => {
            const handleClickOutside = (event) => {
                if (footnoteRef.current && !footnoteRef.current.contains(event.target) &&
                    commentRef.current && !commentRef.current.contains(event.target)) {
                    setIsVisible(false);
                    document.body.classList.remove('footnote-active');
                }
            };

            document.addEventListener('mousedown', handleClickOutside);
            return () => {
                document.removeEventListener('mousedown', handleClickOutside);
            };
        }, []);

        const toggleComment = (e) => {
            e.stopPropagation();
            setIsVisible(!isVisible);
            document.body.classList.toggle('footnote-active', !isVisible);
        };

        return (
            <span className="footnote-container">
                <span
                    ref={footnoteRef}
                    className={`footnote-wrapper ${isVisible ? 'active' : ''}`}
                    onClick={toggleComment}
                >
                    <span
                        className="footnote-text"
                        style={{ borderBottom: 'none !important' }}
                        dangerouslySetInnerHTML={{ __html: parseInlineFormatting(children) }}
                    />
                    <sup className="footnote-star">*</sup>
                </span>
                {isVisible && (
                    <span
                        ref={commentRef}
                        className="comment visible"
                    >
                        {comment}
                    </span>
                )}
            </span>
        );
    };

    const parseContent = (content) => {
        const blocks = [];
        const lines = content.split('\n');
        let inImageBlock = false;
        let currentImages = [];
        let chapters = [];
        let inCenteredTextBlock = false;
        let centeredTextContent = []; // для накопления текста внутри многострочного блока

        lines.forEach(line => {
            if (line.trim().startsWith('# ')) {
                const chapterTitle = line.trim().slice(2);
                chapters.push(chapterTitle);
                blocks.push({ type: 'chapter', content: chapterTitle });
            } else if (line.trim() === '[IMG]') {
                inImageBlock = true;
                currentImages = [];
            } else if (line.trim() === '[/IMG]') {
                if (currentImages.length > 0) {
                    blocks.push({ type: 'image', content: currentImages });
                }
                inImageBlock = false;
            } else if (inImageBlock) {
                if (line.trim()) {
                    currentImages.push(line.trim());
                }
            }
            // Проверяем начало многострочного блока
            else if (line.trim() === '@' && !inCenteredTextBlock) {
                inCenteredTextBlock = true;
                centeredTextContent = []; // очищаем накопитель для многострочного текста
            }
            // Проверяем конец многострочного блока
            else if (line.trim() === '@' && inCenteredTextBlock) {
                // Если текст накоплен, добавляем его как блок centeredText
                if (centeredTextContent.length > 0) {
                    blocks.push({
                        type: 'centeredText',
                        content: parseInlineFormatting(centeredTextContent.join('\n').trim())
                    });
                }
                inCenteredTextBlock = false; // завершаем многострочный блок
            }
            // Накопление текста в многострочном блоке
            else if (inCenteredTextBlock) {
                centeredTextContent.push(line);
            }
            // Обработка одиночного блока @текст@
            else if (line.startsWith('@') && line.endsWith('@')) {
                blocks.push({
                    type: 'centeredText',
                    content: parseInlineFormatting(line.slice(1, -1).trim())
                });
            }
            // Обычный текст, если он не в многострочном блоке
            else {
                const match = line.trim().match(/^<p>(.*)<\/p>$/);
                if (match) {
                    blocks.push({
                        type: 'text',
                        content: parseInlineFormatting(match[1].trim())
                    });
                }
            }
        });

        return { blocks, chapters };
    };

    const TextBlock = ({ content, fontSize }) => {
        return (
            <span
                style={{
                    fontSize: `${fontSize}px`,
                    textIndent: '30px',
                    display: 'block'
                }}
                dangerouslySetInnerHTML={{
                    __html: parseInlineFormatting(content)  // Применяем здесь
                }}
            />
        );
    };

    const CenteredTextBlock = ({ content }) => {
        return (
            <div
                style={{
                    display: 'flex',
                    justifyContent: 'center',
                    padding: '10px 10%',
                    flexDirection: 'column'
                }}
                dangerouslySetInnerHTML={{
                    __html: parseInlineFormatting(content)  // Применяем здесь
                }}
            />
        );
    };

    const ImageBlock = ({ content, setIsImageEnlarged }) => {
        const [currentIndex, setCurrentIndex] = React.useState(0);
        const [isEnlarged, setIsEnlarged] = React.useState(false);
        const imageRef = React.useRef(null);
        const captionContainerRef = React.useRef(null);
        const [captionHeight, setCaptionHeight] = React.useState('auto');
        const [touchStart, setTouchStart] = React.useState(null);
        const [touchEnd, setTouchEnd] = React.useState(null);
        const [isSwiping, setIsSwiping] = React.useState(false);

        const minSwipeDistance = 50;

        const images = [];
        for (let i = 0; i < content.length; i += 2) {
            images.push({
                url: content[i],
                caption: content[i + 1] || '',
            });
        }

        React.useEffect(() => {
            images.forEach((image) => {
                const img = new Image();
                img.src = image.url;
            });
        }, [images]);

        const nextImage = (e) => {
            if (e) e.stopPropagation();
            setCurrentIndex((prevIndex) => (prevIndex + 1) % images.length);
        };

        const prevImage = (e) => {
            if (e) e.stopPropagation();
            setCurrentIndex((prevIndex) => (prevIndex - 1 + images.length) % images.length);
        };

        const toggleEnlarged = (e) => {
            if (isSwiping) return;
            e.stopPropagation();
            setIsEnlarged(!isEnlarged);
            setIsImageEnlarged(!isEnlarged);
        };

        const onTouchStart = (e) => {
            setTouchEnd(null);
            setTouchStart(e.targetTouches[0].clientX);
        };

        const onTouchMove = (e) => {
            setTouchEnd(e.targetTouches[0].clientX);
            setIsSwiping(true);
        };

        const onTouchEnd = () => {
            if (!touchStart || !touchEnd) return;

            const distance = touchStart - touchEnd;
            const isLeftSwipe = distance > minSwipeDistance;
            const isRightSwipe = distance < -minSwipeDistance;

            if (isLeftSwipe) {
                nextImage();
            } else if (isRightSwipe) {
                prevImage();
            }

            setTouchStart(null);
            setTouchEnd(null);

            setTimeout(() => {
                setIsSwiping(false);
            }, 100);
        };

        return (
            <div className="my-8 p-4 bg-white text-gray-600">
                <div className="relative w-full max-h-screen aspect-video">
                    <div className="absolute inset-0 flex justify-center items-center">
                        <div className="relative w-full h-full">
                            <img
                                ref={imageRef}
                                src={images[currentIndex].url}
                                alt={images[currentIndex].caption}
                                className="cursor-pointer object-contain w-full h-full"
                                onClick={toggleEnlarged}
                            />
                            <div
                                className="absolute bottom-[2%] left-1/2 -translate-x-1/2 bg-black/50 text-white whitespace-nowrap text-[clamp(1.5px,0.9vw,10px)] px-[clamp(3px,0.75vw,6px)] py-[clamp(1.5px,0.5vw,3px)] rounded"
                            >
                                © James Abbe Archive / www.jamesabbe.com
                            </div>
                        </div>
                    </div>
                    {images.length > 1 && (
                        <>
                            <button
                                onClick={prevImage}
                                className="absolute left-2 top-1/2 -translate-y-1/2 p-8 bg-zinc-200/50 hover:bg-zinc-200/80 text-stone-200 rounded-full z-10"
                            >
                                ❮
                            </button>
                            <button
                                onClick={nextImage}
                                className="absolute right-2 top-1/2 -translate-y-1/2 p-8 bg-zinc-200/50 hover:bg-zinc-200/80 text-white rounded-full z-10"
                            >
                                ❯
                            </button>
                        </>
                    )}
                </div>

                <div
                    ref={captionContainerRef}
                    className="mt-4 transition-all duration-300 ease-in-out text-center italic max-w-[90%] mx-auto"
                    style={{
                        height: captionHeight,
                        minHeight: '1.5em',
                    }}
                >
                    <span className="block text-center italic max-w-[90%] mx-auto">
                        {renderTextWithFootnotes(images[currentIndex].caption)}
                    </span>
                </div>

                {isEnlarged && (
                    <div
                        className="fixed inset-0 flex items-center justify-center bg-black/80 touch-pan-y"
                        onClick={toggleEnlarged}
                        onTouchStart={onTouchStart}
                        onTouchMove={onTouchMove}
                        onTouchEnd={onTouchEnd}
                        style={{ zIndex: 1010 }}
                    >
                        <div className="relative inline-block">
                            <img
                                src={images[currentIndex].url}
                                alt={images[currentIndex].caption}
                                className="max-w-[90vw] max-h-[90vh]"
                            />
                            <div
                                className="absolute bottom-[2%] left-1/2 -translate-x-1/2 bg-black/50 text-white whitespace-nowrap text-[clamp(5px,1.25vw,12px)] px-[clamp(3px,0.75vw,6px)] py-[clamp(1.5px,0.5vw,3px)] rounded"
                            >
                                © James Abbe Archive / www.jamesabbe.com
                            </div>
                        </div>
                    </div>
                )}
            </div>
        );
    };



    // Модифицированный компонент TableOfContents
    const TableOfContents = ({
        chapters,
        allChapterTitles,
        activeChapter,
        onChapterSelect,
        isOpen,
        width = '32rem',
        isMobile
    }) => {
        const listRef = React.useRef(null);
        const activeItemRef = React.useRef(null);

        React.useEffect(() => {
            if (isOpen && activeItemRef.current && listRef.current) {
                const listContainer = listRef.current;
                const activeItem = activeItemRef.current;
                const itemTop = activeItem.offsetTop;
                const containerHeight = listContainer.clientHeight;
                const itemHeight = activeItem.clientHeight;
                listContainer.scrollTop = itemTop - (containerHeight / 2) + (itemHeight / 2);
            }
        }, [activeChapter, isOpen]);

        if (!isOpen) return null;

        return (
            <>
                {isMobile && (
                    <div className="fixed inset-0 bg-black bg-opacity-50 z-[1000]" />
                )}

                <div
                    ref={listRef}
                    className={`table-of-contents bg-white overflow-auto shadow-lg z-50 transition-transform duration-300
                        ${isMobile
                            ? 'fixed inset-0 z-[1004]'
                            : 'fixed top-0 right-0 h-full w-72 transform'
                        }`}
                >
                    <div className="p-6">
                        <ul className="space-y-2 mt-12">
                            {allChapterTitles.map((title, index) => (
                                <li
                                    key={index}
                                    ref={index === activeChapter ? activeItemRef : null}
                                    className={`cursor-pointer p-2 rounded transition-colors
                                        ${activeChapter === index
                                            ? 'bg-zinc-300 dark:bg-zinc-100 dark:text-black font-bold'
                                            : 'hover:bg-gray-100'
                                        }`}
                                    onClick={() => onChapterSelect(index)}
                                >
                                    {title}
                                </li>
                            ))}
                        </ul>
                    </div>
                </div>
            </>
        );
    };

    // Новый компонент навигации между главами
    const ChapterNavigation = ({
        activeChapter,
        totalChapters,
        onChapterSelect,
        isVisible,
        tocIsOpen,
        isMobile,
        chapterReadCount
    }) => {
        const [forceShow, setForceShow] = React.useState(false);

        React.useEffect(() => {
            const handleScroll = () => {
                // Определяем, находимся ли мы близко к концу страницы
                const scrollPosition = window.scrollY + window.innerHeight;
                const pageHeight = document.documentElement.scrollHeight;
                const isNearBottom = pageHeight - scrollPosition < 100; // 100px от конца

                setForceShow(isNearBottom);
            };

            window.addEventListener('scroll', handleScroll, { passive: true });
            return () => window.removeEventListener('scroll', handleScroll);
        }, []);

        const showPrevButton = activeChapter > 0;
        const showNextButton = activeChapter < totalChapters - 1;

        // Показываем навигацию если isVisible === true ИЛИ forceShow === true
        const shouldShow = isVisible || forceShow;

        return (
            <div className={`fixed bottom-0 left-0 right-0 ChapterNavigation transition-all duration-300 ease-in-out
                ${shouldShow ? 'translate-y-0' : 'translate-y-full'}
                ${(isMobile && tocIsOpen) ? 'opacity-0' : 'opacity-100'}
                ${tocIsOpen && !isMobile ? 'pr-72' : ''}`}
            >
                <div className="max-w-3xl min-w-[350px] mx-auto p-2 bg-white shadow-lg dark:white flex justify-between items-center">
                    {showPrevButton ? (
                        <button
                            onClick={() => onChapterSelect(activeChapter - 1)}
                            className="px-4 py-2 bg-white hover:font-semibold"
                        >
                            ← Глава {activeChapter}
                        </button>
                    ) : <div />}

                    {/* Добавляем счётчик прочтений в центр */}
                    <div className="text-sm text-gray-600">
                        ⚆ {chapterReadCount}
                    </div>

                    {showNextButton ? (
                        <button
                            onClick={() => onChapterSelect(activeChapter + 1)}
                            className="px-4 py-2 bg-white hover:font-semibold"
                        >
                            Глава {activeChapter + 2} →
                        </button>
                    ) : <div />}
                </div>
            </div>
        );
    };

    // Parsing function for inline formatting (italic, bold)
    const parseInlineFormatting = (text) => {
        // Parse italic text
        text = text.replace(/\/\/(.*?)\/\//g, '<i>$1</i>');
        // Parse bold text
        text = text.replace(/\|\|(.*?)\|\|/g, '<strong>$1</strong>');
        return text;
    };

    // Модифицированный основной компонент
    const App = () => {
        // Инициализация состояний
        const [fontSize, setFontSize] = React.useState(() => {
            const saved = localStorage.getItem(STORAGE_KEYS.FONT_SIZE);
            return saved ? parseInt(saved, 10) : 16;
        });

        const [showToc, setShowToc] = React.useState(false);
        const [activeChapter, setActiveChapter] = React.useState(() => {
            const saved = localStorage.getItem(STORAGE_KEYS.ACTIVE_CHAPTER);
            return saved ? parseInt(saved, 10) : 0;
        });

        const [isDarkTheme, setIsDarkTheme] = React.useState(() => {
            const saved = localStorage.getItem(STORAGE_KEYS.THEME);
            const initialTheme = saved ? saved === 'dark' : false;
            if (initialTheme) {
                document.body.classList.add('dark-mode');
            }
            return initialTheme;
        });

        const [lastScrollTop, setLastScrollTop] = React.useState(0);
        const [showControlPanel, setShowControlPanel] = React.useState(true);
        const [isImageEnlarged, setIsImageEnlarged] = React.useState(false);

        // Добавляем состояние для определения мобильного устройства
        const [isMobile, setIsMobile] = React.useState(false);

        const [isScrollLocked, setIsScrollLocked] = React.useState(false);
        const scrollTimeout = React.useRef(null);
        const lastScrollUpdateTime = React.useRef(Date.now());

        // Добавляем состояние для статистики чтения
        const [readingStats, setReadingStats] = React.useState(null);

        // Используем useRef для хранения текущей позиции прокрутки
        const currentScrollPosition = React.useRef(0);

        const [isManualScrolling, setIsManualScrolling] = React.useState(false);
        const [isChapterTransition, setIsChapterTransition] = React.useState(false);
        const lastAutoScrollTimestamp = React.useRef(0);

        React.useEffect(() => {
            // Инициализация трекера при монтировании компонента
            readingTracker.init();

            // Загружаем статистику чтения
            readingTracker.getReadingStats().then(stats => {
                if (stats) {
                    setReadingStats(stats);
                }
            });
        }, []);

        const [currentChapterReadCount, setCurrentChapterReadCount] = React.useState(0);

        React.useEffect(() => {
            // Обновляем счётчик прочтений для активной главы
            if (activeChapter !== null) {
                readingTracker.getChapterReadCount(activeChapter)
                    .then(setCurrentChapterReadCount);
            }
        }, [activeChapter]);

        React.useEffect(() => {
            let scrollTimeout;

            const handleScroll = () => {
                clearTimeout(scrollTimeout);
                scrollTimeout = setTimeout(() => {
                    if (!chapters[activeChapter]) return;

                    const element = chapterRefs.current[activeChapter];
                    if (!element) return;

                    const rect = element.getBoundingClientRect();
                    const windowHeight = window.innerHeight;

                    const totalHeight = rect.height;
                    const scrolledHeight = Math.max(0, windowHeight - rect.top);
                    const progress = Math.min(Math.max(scrolledHeight / totalHeight, 0), 1);

                    console.log('Normalized scroll progress for active chapter:', progress);
                    readingTracker.updateScrollProgress(progress);
                }, 100); // Задержка в 100 миллисекунд
            };

            window.addEventListener('scroll', handleScroll, { passive: true });
            return () => window.removeEventListener('scroll', handleScroll);
        }, [activeChapter, chapters]);

        React.useEffect(() => {
            readingTracker.setCurrentChapter(activeChapter);
        }, [activeChapter]);

        React.useEffect(() => {
            let scrollTimeout;

            const handleScroll = () => {
                const currentTime = Date.now();

                // Игнорируем события прокрутки во время программной навигации
                if (isChapterTransition || currentTime - lastAutoScrollTimestamp.current < 1000) {
                    return;
                }

                const scrollY = window.scrollY + window.innerHeight / 3;
                let newActiveIndex = activeChapter;

                // Находим текущую видимую главу
                chapterRefs.current.forEach((ref, index) => {
                    if (ref && ref.offsetTop <= scrollY) {
                        newActiveIndex = index;
                    }
                });

                // Обновляем активную главу только при ручной прокрутке
                if (newActiveIndex !== activeChapter && !isChapterTransition) {
                    setActiveChapter(newActiveIndex);
                }
            };

            window.addEventListener('scroll', handleScroll, { passive: true });
            return () => {
                window.removeEventListener('scroll', handleScroll);
                clearTimeout(scrollTimeout);
            };
        }, [activeChapter, isChapterTransition]);

        // Функция для обновления состояния isMobile при изменении размера окна
        React.useEffect(() => {
            const checkMobileView = () => {
                setIsMobile(window.innerWidth < 768); // Определяем как мобильное устройство, если ширина экрана меньше 768px
            };

            checkMobileView(); // Проверяем при загрузке
            window.addEventListener('resize', checkMobileView); // Обновляем при изменении размера окна
            return () => window.removeEventListener('resize', checkMobileView);
        }, []);

        // Остальные состояния и обработчики
        const [loadedChapterIndices, setLoadedChapterIndices] = React.useState([]);
        const { chapters, isLoading, error, loadChapter, allChapterTitles } = useChapterLoader();
        const chapterRefs = React.useRef([]);

        React.useEffect(() => {
            localStorage.setItem(STORAGE_KEYS.THEME, isDarkTheme ? 'dark' : 'light');
        }, [isDarkTheme]);

        React.useEffect(() => {
            localStorage.setItem(STORAGE_KEYS.ACTIVE_CHAPTER, activeChapter.toString());
        }, [activeChapter]);

        React.useEffect(() => {
            localStorage.setItem(STORAGE_KEYS.FONT_SIZE, fontSize.toString());
        }, [fontSize]);

        React.useEffect(() => {
            const handleScroll = () => {
                const st = window.pageYOffset || document.documentElement.scrollTop;
                setShowControlPanel(st < lastScrollTop);
                setLastScrollTop(st <= 0 ? 0 : st);
            };

            window.addEventListener('scroll', handleScroll);
            return () => window.removeEventListener('scroll', handleScroll);
        }, [lastScrollTop]);

          React.useEffect(() => {
            const initialLoadChapters = async () => {
              const savedChapter = parseInt(localStorage.getItem(STORAGE_KEYS.ACTIVE_CHAPTER), 10) || 0;

              // Сначала загружаем текущую главу
              await loadChapter(savedChapter);
              setLoadedChapterIndices(prev => [...prev, savedChapter]);

            };

            if (allChapterTitles.length > 0) {
              initialLoadChapters();
            }
          }, [loadChapter, allChapterTitles.length]);

        React.useEffect(() => {
            const handleScroll = async () => {
                const scrollPosition = window.scrollY + window.innerHeight;
                const totalHeight = document.body.scrollHeight;

                if (scrollPosition >= totalHeight * 0.8) {
                    const nextChapterIndex = Math.max(...loadedChapterIndices) + 1;
                    if (nextChapterIndex < allChapterTitles.length) {
                        await loadChapter(nextChapterIndex);
                        setLoadedChapterIndices(prev => [...prev, nextChapterIndex]);
                    }
                }

                const topScrollPosition = window.scrollY;
                if (topScrollPosition <= window.innerHeight * 0.3) {
                    const prevChapterIndex = Math.min(...loadedChapterIndices) - 1;
                    if (prevChapterIndex >= 0) {
                        await loadChapter(prevChapterIndex);
                        setLoadedChapterIndices(prev => [...prev, prevChapterIndex]);
                    }
                }

                const scrollY = window.scrollY + window.innerHeight / 3;
                let newActiveIndex = 0;
                chapterRefs.current.forEach((ref, index) => {
                    if (ref && ref.offsetTop <= scrollY) {
                        newActiveIndex = index;
                    }
                });
                if (newActiveIndex !== activeChapter) {
                    setActiveChapter(newActiveIndex);
                }
            };

            window.addEventListener('scroll', handleScroll);
            return () => window.removeEventListener('scroll', handleScroll);
        }, [loadChapter, loadedChapterIndices, allChapterTitles.length, activeChapter]);

        const handleChapterSelect = async (index) => {
            if (index < 0 || index >= allChapterTitles.length || activeChapter === index) {
                console.log('Invalid chapter selection or chapter already active:', index);
                return;
            }

            setIsChapterTransition(true);
            setActiveChapter(index);

            // Сбрасываем прокрутку в начало страницы
            window.scrollTo(0, 0);

            if (!loadedChapterIndices.includes(index)) {
                await loadChapter(index);
                setLoadedChapterIndices((prev) => [...prev, index]);
            }

            // Принудительное обновление прогресса после загрузки
            const element = chapterRefs.current[index];
            if (element) {
                const rect = element.getBoundingClientRect();
                const windowHeight = window.innerHeight;
                const totalHeight = rect.height;
                const scrolledHeight = Math.max(0, windowHeight - rect.top);
                const progress = Math.min(Math.max(scrolledHeight / totalHeight, 0), 1);

                console.log('Manually triggering scroll progress for chapter:', index, 'Progress:', progress);
                readingTracker.updateScrollProgress(progress);
            }

            // Закрываем оглавление, если это мобильная версия
            if (isMobile) {
                setShowToc(false);
            }

            setIsChapterTransition(false);
        };

            // Обновленный эффект для отслеживания загруженных глав
        React.useEffect(() => {
            const updateChapterRefs = () => {
                chapters.forEach((chapter, index) => {
                    if (chapter) {
                        const element = document.querySelector(`[data-chapter-index="${index}"]`);
                        if (element) {
                            chapterRefs.current[index] = element;
                        }
                    }
                });
            };

            updateChapterRefs();

            // Обновляем refs после каждой загрузки новой главы
            const observer = new MutationObserver(updateChapterRefs);
            observer.observe(document.getElementById('root'), {
                childList: true,
                subtree: true
            });

            return () => observer.disconnect();
        }, [chapters]);

        const toggleToc = () => setShowToc(!showToc);

        const increaseFontSize = () => {
            setFontSize(prev => Math.min(prev + 2, 24));
        };

        const decreaseFontSize = () => {
            setFontSize(prev => Math.max(prev - 2, 12));
        };

        const toggleTheme = () => {
            setIsDarkTheme(!isDarkTheme);
            document.body.classList.toggle('dark-mode');
        };

        return (
            <div className="App">
                <div className={`transition-all duration-300 ${showToc && !isMobile ? 'mr-72' : ''}`}>
                    <div className="max-w-3xl mx-auto relative min-w-[350px]">
                        <ControlPanel
                            toggleToc={toggleToc}
                            increaseFontSize={increaseFontSize}
                            decreaseFontSize={decreaseFontSize}
                            isVisible={showControlPanel && !isImageEnlarged}
                            toggleTheme={toggleTheme}
                            isDarkTheme={isDarkTheme}
                            tocIsOpen={showToc}
                        />

                        {isLoading && (
                            <div className="text-center py-4">
                                <span className="inline-block px-4 py-2 text-gray-200 rounded">
                                    Загрузка...
                                </span>
                            </div>
                        )}

                        {error && (
                            <div className="text-center py-4">
                                <span className="inline-block px-4 py-2 bg-red-100 text-red-700 rounded">
                                    {error}
                                </span>
                            </div>
                        )}

                        <div className="p-4">
                            <div className="bg-white shadow-lg rounded-lg p-6">
                                {/* Отображаем только активную главу */}
                                {chapters[activeChapter] && (
                                    <div
                                        key={activeChapter}
                                        ref={el => chapterRefs.current[activeChapter] = el}
                                        data-chapter-index={activeChapter}
                                        className="mb-32" // Добавляем большой отступ после каждой главы
                                    >
                                        {chapters[activeChapter].blocks.map((block, blockIndex) => {
                                            if (block.type === 'text') {
                                                return (
                                                    <p key={blockIndex} style={{ fontSize: `${fontSize}px`, textIndent: 30 }}>
                                                        {renderTextWithFootnotes(block.content)}
                                                    </p>
                                                );
                                            } else if (block.type === 'centeredText') {
                                                return (
                                                    <CenteredTextBlock
                                                        key={blockIndex}
                                                        content={block.content}
                                                    />
                                                );
                                            } else if (block.type === 'chapter') {
                                                return (
                                                    <h1 key={blockIndex} className="text-2xl font-bold my-16">
                                                        {block.content}
                                                    </h1>
                                                );
                                            } else if (block.type === 'image') {
                                                return (
                                                    <ImageBlock
                                                        key={blockIndex}
                                                        content={block.content}
                                                        setIsImageEnlarged={setIsImageEnlarged}
                                                    />
                                                );
                                            }
                                            return null;
                                        })}
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>
                </div>

                {showToc && (
                    <TableOfContents
                        chapters={chapters}
                        allChapterTitles={allChapterTitles}
                        activeChapter={activeChapter}
                        onChapterSelect={handleChapterSelect}
                        isOpen={showToc}
                        isMobile={isMobile}
                    />
                )}
                <ChapterNavigation
                    activeChapter={activeChapter}
                    totalChapters={allChapterTitles.length}
                    onChapterSelect={handleChapterSelect}
                    isVisible={showControlPanel && !isImageEnlarged}
                    allChapterTitles={allChapterTitles}
                    tocIsOpen={showToc}
                    isMobile={isMobile}
                    chapterReadCount={currentChapterReadCount}
                />
            </div>
        );
    };


    // Вспомогательные функции для рендеринга текста с примечаниями
    const renderTextWithFootnotes = (text) => {
      const footnoteRegex = /\[([^\]]+)\*([^\]]+)\*\*\]/g;
      const parts = text.split(footnoteRegex);

      return parts.map((part, i) => {
        if (i % 3 === 1) {
          const word = part;
          const comment = parts[i + 1];
          return (
            <Footnote key={i} comment={comment}>
              {word}
            </Footnote>
          );
        } else if (i % 3 === 0) {
          return (
            <span
              key={i}
              dangerouslySetInnerHTML={{
                __html: parseInlineFormatting(part)
              }}
            />
          );
        }
        return null;
      });
    };

    // Рендерим приложение
    ReactDOM.render(<App />, document.getElementById('root'));
</script>
<body>
<div id="root"></div>
    <div id="overlay"></div>
</body>
</html>
